tinymce.PluginManager.add('ghostwriter-comments', function(editor) {
    // Function to decode the users hex username into ascii
    function hex2ascii(hexString) {
        let decodedStr = '';
        for (let i = 0; i < hexString.length; i += 2) {
            const byte = parseInt(hexString.substr(i, 2), 16);
            decodedStr += String.fromCharCode(byte);
        }
        return decodedStr
    }

    function getCommentNode(node) {
        while (node) {
            if (node.nodeType === Node.ELEMENT_NODE && node.tagName.toLowerCase() === 'span' && node.classList.contains('comment')) {
                return node;
            }
            node = node.parentNode;
        }
        return null;
    };

    // Create Comments
    function createComment(selection, commentThread) {
        editor.execCommand('mceInsertContent', false, `<span class="comment" comment-data="${encodeURIComponent(JSON.stringify(commentThread))}">${selection}</span>`);
    }

    // Read Comments
    function readCommentNode(node) {
        let commentThread = [];
        commentDataDecoded = decodeURIComponent(node.getAttribute('comment-data'));
        if (!commentDataDecoded) {
            return commentThread;
        }
        commentData = JSON.parse(commentDataDecoded);
        commentData.forEach(item => {
            const author = item.author;
            const comment = item.comment;
            commentThread.push({ author: author, comment: comment });
        });
        return commentThread;
    }

    function readCommentThread(editedComments) {
        let commentThread = [];
        editedComments.forEach(item => {
            const author = item.getAttribute('data-author');
            var comment = item.textContent;
            if (!comment) {
                comment = item.value;
            }
            commentThread.push({ author: author, comment: comment });
        });
        return commentThread;
    }

    // Display Comments
    function displayComments(commentThread) {
        let commentsThread = '<div id="entire-comment-thread">';
        commentThread.forEach(item => {
            const author = item.author;
            const comment = item.comment;
            const selfclass = author === username ? 'comment from-self' : 'comment';
            commentsThread +=
            `<div class="${selfclass}">
                <div class="comment-header">
                    <h1>${tinymce.DOM.encode(hex2ascii(author))}</h1>
                    <img class="comment-avatar" src="/users/${encodeURIComponent(hex2ascii(author))}/avatar" alt="Avatar">
                </div>
                <div class="comment-body">
                    <p class="comment-text" data-author="${author}">${tinymce.DOM.encode(comment)}</p>
                </div>
            </div>`;
        });
        commentsThread += '</div>';
        return commentsThread;
    }

    // Resolve Comments
    function resolveComment(node) {
        node.className = 'comment-resolved';
    }

    editor.ui.registry.addNestedMenuItem('comments', {
        icon: 'comment',
        text: 'Comments',
        getSubmenuItems: () => [
            {
                type: 'menuitem',
                text: 'Create comment',
                onAction: function () {
                    const commentBox = editor.windowManager.open({
                        title: 'Create',
                        body: {
                            type: 'panel',
                            items: [
                                {
                                    type: 'textarea',
                                    name: 'comment',
                                    label: 'Comment'
                                }
                            ]
                        },
                        buttons: [
                            {
                                type: 'cancel',
                                text: 'Cancel'
                            },
                            {
                                type: 'submit',
                                text: 'Save',
                                primary: true
                            }
                        ],
                        onSubmit: function (api) {
                            const data = api.getData();
                            content = editor.selection.getContent();
                            if (content === '') {
                                var selRng = editor.selection.getRng();
                                selRng.expand("word");
                                editor.selection.setRng(selRng);
                                content = editor.selection.getContent();
                            }
                            createComment(content, [{ author: username, comment: data.comment }]);
                            api.close();
                        }
                    });
                }
            },
            {
                type: 'menuitem',
                text: 'View comments',
                onAction: function () {
                    const node = editor.selection.getNode();
                    const commentNode = getCommentNode(node);
                    const existingComments = readCommentNode(commentNode);
                    const commentsHTML = displayComments(existingComments);
                    const commentBox = editor.windowManager.open({
                        title: 'View',
                        body: {
                            type: 'panel',
                            items: [
                                {
                                    type: 'label',
                                    label: 'Click on your existing comments to edit',
                                    for: 'existingComments',
                                    items: [
                                        {
                                            type: 'htmlpanel',
                                            name: 'existingComments',
                                            html: commentsHTML,
                                        }
                                    ]
                                },
                                {
                                    type: 'textarea',
                                    name: 'reply',
                                    label: 'Relpy'
                                }
                            ]
                        },
                        buttons: [
                            {
                                type: 'cancel',
                                text: 'Cancel'
                            },
                            {
                                type: 'custom',
                                text: 'Resolve'
                            },
                            {
                                type: 'submit',
                                text: 'Save',
                                primary: true
                            }
                        ],
                        onSubmit: function (api) {
                            const data = api.getData();
                            const editedComments = document.querySelectorAll('.comment-text');
                            let commentThread = readCommentThread(editedComments);
                            if (data.reply != '') {
                                commentThread.push({ author: username, comment: data.reply });
                            }
                            editor.selection.select(commentNode.firstChild)
                            createComment(editor.selection.getContent(), commentThread);
                            api.close();
                        },
                        onAction: (api) => {
                            resolveComment(node);
                            api.close();
                        }
                    });
                }
            }
        ]
    });
});

document.addEventListener('click', function (event) {
    if (event.target.classList.contains('comment-text')) {
        const pTag = event.target;
        const author = pTag.getAttribute('data-author');
        if (author === username) {
            const input = document.createElement('input');
            input.type = 'text';
            input.value = pTag.textContent;
            input.className = 'comment-text';
            input.setAttribute('data-author', author);
            pTag.replaceWith(input);
            input.focus();

            input.addEventListener('blur', function () {
                const newPTag = document.createElement('p');
                newPTag.className = 'comment-text';
                newPTag.setAttribute('data-author', author);
                newPTag.textContent = input.value;
                input.replaceWith(newPTag);
            });
            input.addEventListener('keydown', function (e) {
                if (e.key === 'Enter') {
                    input.blur();
                }
            });
        }
    }
});